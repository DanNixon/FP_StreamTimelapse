Usage
=====

Note: assuming SSH access opposed to local terminal.

If capture is configured to start on boot type ```sudo reboot``` to reboot the Pi in order to start capture, otherwise execute ```start_timelapse.sh``` to start capture.

If GPS features are enabled the Pi will wait until a GPS lock has been obtained, if after around 5 seconds after the lock has been obtained the light on the RasPI camera module is lit then capture has successfully started. In both cases capture can be stopped by executing ```stop_timelapse.sh```.

In case of power failure the script should restart timelapse capture from the last image saved (with possible corruption of one original image and 0-5 equi images).

If the Pi fails to start capture (usually after power failure) then it will attempt to perform auto recovery, in this process it will execute ```recovery.sh```, cleaning the directory of images and logfiles (by moving them to an archive folder, "recoveryN") and rebuilding the capture application.

A log (screenlog.0) is generated by screen and shows output from the capure application and mjpg-streamer.

If launched using cron, a log (cron_tl.log) will be created which details starting components and will show if the timelapse has failed to start.

Using without a terminal
------------------------

The ```gpio_halt.sh``` script is used to provide a method of controlling the recording state without having to access the Pi over SSH. This assumes that ```start_timelapse.sh``` is configured to run on boot using cron.

When the Pi boots it will automatically start timelapse recording, this can be stopped by pressing the stop button (see INSTALL_CONFIG) for around 1 second, this will run the ```stop_timelapse.sh``` script then shutdown and halt the Pi (leaving power on to the GPS module in order to maintain the GPS lock).

When the Pi is halted you can press the start/boot button to restart the Pi and being the capture, the Pi will behave as if it has just had the power connected, however the capture will start sooner as a GPS lock will already be established.

The following table can be used to determine the state of the Pi and capture based on the status lights. Note: assumes use of a the Adafruit Ultimate GPS (or module with equivalent FIX status), **ACT**, **PWR**, **FDX** and **LNK** are the status LEDs on the Pi, **CM** is the status LED on the camera module, **FIX** is the GPS fix indicator, *n/a* incicates that the state of an LED is not relevant to the state indicated.
<table>
<tr>
	<th>ACT</th><th>PWR</th><th>FDX</th><th>LNK</th><th>CM</th><th>FIX</th><th>State</th>
</tr>
<tr>
	<td>Fast Blink</td>
	<td>Solid</td>
	<td>Solid</td>
	<td>Occasional Blink</td>
	<td>Off</td>
	<td>Slow Blink</td>
	<td>RasPi is booting, seeking GPS lock, network connected</td>
</tr>
<tr>
	<td>Occasional Blink</td>
	<td>Solid</td>
	<td>Solid</td>
	<td>Occasional Blink</td>
	<td>Off</td>
	<td>1Hz blink</td>
	<td>RasPi has booted, waiting for GPS lock, network connected</td>
</tr>
<tr>
	<td>~1Hz Blink</td>
	<td>Solid</td>
	<td>Solid</td>
	<td>Almost constant fast blinking</td>
	<td>~1Hz Blink</td>
	<td>1/15Hz Blink</td>
	<td>Capture is running, transmitting to server</td>
</tr>
<tr>
	<td>~1Hz Blink</td>
	<td>Solid</td>
	<td>Solid</td>
	<td>Almost constant fast blinking</td>
	<td>~1Hz Blink</td>
	<td>1Hz Blink</td>
	<td>GPS lock has been lost, continuing capture</td>
</tr>
<tr>
	<td>~1Hz Blink</td>
	<td>Solid</td>
	<td>Off</td>
	<td>Off</td>
	<td>~1Hz Blink</td>
	<td>1/15Hz Blink</td>
	<td>Network connection has been lost, continuing capture</td>
</tr>
<tr>
	<td>~1Hz Blink</td>
	<td>Solid</td>
	<td>Solid</td>
	<td>Occasional Blink</td>
	<td>~1Hz Blink</td>
	<td>1/15Hz Blink</td>
	<td>Internet connection has been lost, continuing capture</td>
</tr>
<tr>
	<td>Occasional Blink</td>
	<td>Solid</td>
	<td>Solid</td>
	<td>Occasional Blink</td>
	<td>Solid</td>
	<td>1/15Hz Blink</td>
	<td>Unknown capture failure</td>
</tr>
<tr>
	<td>Occasional Blink</td>
	<td>Solid</td>
	<td>Solid</td>
	<td>Occasional Blink</td>
	<td>Off</td>
	<td>1/15Hz Blink</td>
	<td>Unknown capture failure (possibly GPS related)</td>
</tr>
<tr>
	<td>n/a</td>
	<td>Solid</td>
	<td>Solid</td>
	<td><em>n/a</em></td>
	<td><em>n/a</em></td>
	<td>Off</td>
	<td>GPS failure</td>
</tr>
<tr>
	<td>Off</td>
	<td>Off</td>
	<td>Off</td>
	<td>Off</td>
	<td>Off</td>
	<td>Off</td>
	<td>Power failure</td>
</tr>
<tr>
	<td>Off</td>
	<td>Solid</td>
	<td>Off</td>
	<td>Off</td>
	<td>Off</td>
	<td>1/15Hz Blink</td>
	<td>RasPi is halted, with GPS lock</td>
</tr>
<tr>
	<td>Off</td>
	<td>Solid</td>
	<td>Off</td>
	<td>Off</td>
	<td>Off</td>
	<td>1Hz Blink</td>
	<td>RasPi is halted, seeking GPS lock</td>
</tr>
</table>

If the Pi becomes unresponsive and will not shutdown after holding the stop button for 2 seconds then the start button can be pressed to reset the BCM2835, however this may cause data corruption.

Exporting a timelapse
---------------------

Both the raw images captured by the camera and the equi. images are stored in the "tl_images" folder (or other folder if configured in ```start_timelapse.sh```), from here they can be copied from the Pi either using SFTP or by mounting the SD card on a desktop.

The file ```last_frame_no.log``` is used to identify the frame number of the last timeplapse frame captured, which is used to continue a timelapse when the script is stopped then restarted (e.g. power failure), this also provides a way to export a partial timelapse and continue capturing from the last frame number so that the folders of several small consecutive captures can be combined and  converted to a single timelapse video (which is useful when recording a timelapse which would not fit on a single SD card).

The ```tl_gen``` script can then be used to create a timelapse video of these images, a sample command would be the following: ```./tl_gen.sh ./equi/[filename].jpg ./[vid_out].mp4```, where [filename] is the filename given in the config stage and [vid_out] is the name of the resulting MP4 video file.

Streaming
---------

A stream of the raw camera captures is available at http://[pi_ip]:8080/?action=stream

The BPStreamViewer application can be used to view this stream, both unwrapped and on a sphere.

Notes
-----

The Pi has no in built RTC, hence system time is dependant on a reply from an NTP server, this may not always be possible, hence if getting a correct time for each image is important use the GPS EXIF data rather than ```EXIF.Image.DateTime```.

GPS time will also be more accurate, direct connection to a GPS device is Stratum 0 whereas NTP is at best Stratum 1.

Because a GPIO pin is used to read the fix indicator, the script must run with root permissions, meaning any images will belong to root (if you download images over SFTP then this isn't a problem).

GPS time is saved in ```EXIF.GPSInfo.GPSDateStamp``` and ```EXIF.GPSInfo.GPSTimeStamp```, it is highly recommended to use this date/time stamp over the standard ```EXIF.Image``` data as the system clock is unlikely to be correct if not on a network.

Troubleshooting
---------------

Use either ```ps aux | grep stream``` or ```screen -ls``` to check status of capture, ~8 processes should be shown with ps and 3-5 screens should be shown with screen (depending on feature configuration).

From the root folder (stream_tl) use ```tail -f screenlog.0``` to monitor capture in real time.

The command ```df``` can be used to monitor the amount  of free space remaining on the SD card.
